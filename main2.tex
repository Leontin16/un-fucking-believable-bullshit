\section{Эксперименты 3.1 и 3.2: Зависимость времени от количества вершин}
\label{sec:exp_n}

\subsection{Методика проведения экспериментов}

Для проведения экспериментов были разработаны две программы:
\begin{itemize}
	\item \texttt{main\_experiments.cpp} — генерация графов и измерение времени выполнения
	\item \texttt{plot\_graphs.py} — визуализация результатов
\end{itemize}

Параметры экспериментов:
\begin{itemize}
	\item Количество вершин $n$: от 1 до 10001 с шагом 100
	\item Веса ребер: случайные в диапазоне $[1, 10^6]$
	\item Начальная вершина: случайная
	\item Каждое измерение повторялось 5 раз, бралось среднее значение
\end{itemize}

\subsection{Эксперимент 3.1: Зависимость от n при разных плотностях графа}

\textbf{Цель:} исследовать влияние количества вершин на производительность при различной плотности графа.

\textbf{Параметры:}
\begin{itemize}
	\item Случай A: $m \approx n^2/10$ (граф средней плотности)
	\item Случай B: $m \approx n^2$ (плотный граф, полный или близкий к нему)
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{picture/result_3_1.png}
\caption{Результаты эксперимента 3.1}
\label{fig:exp3_1}
\end{figure}

\textbf{Наблюдения:}
\begin{enumerate}
	\item При $m \approx n^2/10$ (рис. \ref{fig:exp3_1}, слева):
	\begin{itemize}
		\item Алгоритм A (15-куча) показывает лучшую производительность на больших $n$
		\item При $n > 2000$ алгоритм A быстрее алгоритма B в 2-3 раза
		\item Рост времени алгоритма B близок к квадратичному $O(n^2)$
	\end{itemize}
	
	\item При $m \approx n^2$ (рис. \ref{fig:exp3_1}, справа):
	\begin{itemize}
		\item Оба алгоритма демонстрируют близкую производительность
		\item При больших $n$ алгоритм A имеет незначительное преимущество
		\item Для плотных графов накладные расходы на работу с кучей компенсируются уменьшением количества операций обновления расстояний
	\end{itemize}
\end{enumerate}

\subsection{Эксперимент 3.2: Зависимость от n при линейном количестве ребер}

\textbf{Цель:} исследовать производительность на разреженных графах.

\textbf{Параметры:}
\begin{itemize}
	\item Случай A: $m \approx 100n$ (очень разреженный граф)
	\item Случай B: $m \approx 1000n$ (разреженный граф)
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{picture/result_3_2.png}
\caption{Результаты эксперимента 3.2}
\label{fig:exp3_2}
\end{figure}

\textbf{Наблюдения:}
\begin{enumerate}
	\item При $m \approx 100n$:
	\begin{itemize}
		\item Алгоритм A существенно быстрее при $n > 1000$
		\item При $n = 10000$ разница достигает порядка 10 раз
		\item Это соответствует теории: для разреженных графов $O(n \log n)$ против $O(n^2)$
	\end{itemize}
	
	\item При $m \approx 1000n$:
	\begin{itemize}
		\item Преимущество алгоритма A сохраняется, но менее выражено
		\item При $n = 10000$ алгоритм A быстрее в 5-7 раз
		\item Увеличение плотности уменьшает преимущество кучи, но не устраняет его полностью
	\end{itemize}
\end{enumerate}

\subsection{Выводы по экспериментам 3.1 и 3.2}

\begin{enumerate}
	\item Реализация с 15-кучей демонстрирует существенное преимущество на разреженных графах ($m = O(n)$)
	\item На плотных графах ($m = O(n^2)$) разница в производительности минимальна
	\item Рост времени выполнения алгоритма B соответствует теоретической оценке $O(n^2)$
	\item Алгоритм A масштабируется значительно лучше при увеличении количества вершин
\end{enumerate}